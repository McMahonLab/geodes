---
title: "Building a reference genome database"
author: "Alex Linz"
date: "February 28, 2017"
output: html_document
---

As part of the funding for GEODES, we received several SAG libraries and metagenomes collected the same day as the RNA. This is really great because we're using reference genomes to both classify and annotate our metatranscriptomes. This approach is more accurate than simply classifying and annotating the raw (rather short) RNA reads, but has the downside of ignoring reads that do not map to a reference genome. Therefore, we need the best possible reference genomes to get the most data from our metatranscriptomes.

__Our first priority is choosing which cells to sequence from our SAG libraries__

But besides what is being sequenced with the GEODES grant, what are the best possible genomes? Ideally, we would want highly complete genomes from the same lake and time as the metatranscriptome covering every organism that was expressing genes that day - which we're unlikely to get. But we do have an awesome collection of MAGs and SAGs from 2 out of 3 of the GEODES lakes!  These are already curated, so it makes sense to use these, too. To get even more genomes, could we assemble more from the metagenomic time series or improve on completeness scores by tweaking the parameters? Why not do that with the GEODES metagenomes, too? What about using published genomes from other lakes, or assembling new MAGs from similar lakes? How do you determine which lakes and genomes are similar enough to use?

As you can imagine, building the perfect reference genome database quickly becomes overwhelming. I do not want to spend enormous amounts of time on these projects if they aren't going to help me capture more reads. 

__Given that I have a limited amount of time to spend curating a database, which of these items (if any) do you think would be worth their time investment?__

- Custom assemblies of the GEODES metagenomes (in addition to JGI's assemblies)
- Improving assemblies from the metagenomic time series (in addition to JGI's assemblies)
- Extracting, sequencing, and assembling more samples (especially for poorly representated Sparkling Lake)
- Including published freshwater genomes from other sites
- Assembling genomes from published metagenomes from other sites
- Other ideas?

To help guide this decision, I've mapped the metatranscriptomes we have so far to our reference MAGs and SAGs from Trout Bog and Lake Mendota. I've also classified reads that did not map to the metatranscriptomes using kraken. The results are below.

```{r, setup, echo = F}
library(ggplot2)
library(reshape2)
library(cowplot)

```

```{r, make_genome_table, echo = F, warning = F}
metaT_table <- read.table("C:/Users/Alex/Desktop/geodes/analyses/03process_mapping_results/GEODES_genes_2017-02-27.txt", row.names=1, header = T, fill = NA)
metaT_table <- metaT_table[, 1:72]
metaT_table <- metaT_table[which(rowSums(metaT_table) > 0), ]
colnames(metaT_table) <- substr(colnames(metaT_table), start = 1, stop = 9)

gene_metadata <- read.csv("C:/Users/Alex/Desktop/geodes/analyses/05R_calculations/gene_metadata_2017-02-28.csv")
sample_metadata <- read.csv("C:/Users/Alex/Desktop/geodes/analyses/05R_calculations/sample_metadata.csv")

#Normalize by internal standard
std <- metaT_table[which(rownames(metaT_table) == "pFN18A_DNA_transcript"), ]
std.percent <- std/colSums(metaT_table)*100
std.percent <- melt(std.percent)
metaT_table <- metaT_table/std.percent$value

#Swap out the gene names for the genome classification
genome_table <- metaT_table
trimmed_class <- gsub("^.*?;","", gene_metadata$Phylogeny)
genome_table$Classification <- trimmed_class[match(rownames(metaT_table), gene_metadata$Hits)]

#Switch to long format
genome_table <- melt(genome_table)

#Add a lake column
genome_table$Lake <- sample_metadata$Lake[match(genome_table$variable, sample_metadata$Sample)]

#Remove NAs - this is the standard, ambiguous, and unmapped reads
genome_table <- genome_table[which(is.na(genome_table$Classification) == F), ]

#Summarize read counts by lake and genome
sum_table <- aggregate(genome_table["value"], by = genome_table[c("Classification", "Lake")], FUN = mean)

```

```{r, plot_mapped, echo = F, fig.height = 10}
ggplot(data = sum_table, aes(x = Lake, y = Classification, fill = value)) + geom_tile() + scale_fill_gradient2(low = "white", mid = "seagreen3", high = "black", midpoint = 5) 

```

